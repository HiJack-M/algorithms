##### 数据
* 数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。
* 数据对象：是性质相同的数据元素的集合，是数据的子集。
* 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
* 数据项：一个数据元素可以由若干个数据项组成。

##### 数据结构的定义
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

逻辑结构：
- 集合结构
- 线性结构
- 树形结构
- 图形结构

物理结构：
- 顺序存储结构
- 链接存储结构

为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。

---

##### 函数的渐近增长
输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，则称函数是渐近增长的。
函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，就说f(n)的增长渐近快于g(n)。
2n + 3, 3n + 1  N = 3

判断一个算法好不好，只通过少量的数据是不能做出准确判断的。
如果可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。
这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。

---

##### 算法时间复杂度定义

语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。
算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。
一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。

##### 推导大O阶：
1．用常数1取代运行时间中的所有加法常数。 
2．在修改后的运行次数函数中，只保留最高阶项。 
3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。

- 常数阶：
与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。 
    > 注意：不管这个常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字。

- 线性阶：
  循环结构

- 下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行n次。
```
int i;
for (i = 0; i < n; i++) {
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```
- 对数阶：
```
int count = 1;
while (count < n) {
     count = count * 2;
     /* 时间复杂度为O(1)的程序步骤序列 */ 
}
```
由于每次 count 乘以 2 之后，就距离 n 更近了一分。也就是说，有多少个 2 相乘后大于 n，则会退出循环。由 2x = n 得到 x = log2n。所以这个循环的时间复杂度为 O(logn)。

- 平方阶：
```
for (i = 0; i < n; i++) {
     for (j = 0; j < n; j++)     {
         /* 时间复杂度为O(1)的程序步骤序列 */
     } 
}
```

介个呢？
```
int i, j;
for (i = 0; i < n; i++) {
     /* 注意j = i 而不是0 */
     for (j = i; j < n; j++) {
         /* 时间复杂度为O(1)的程序步骤序列 */
     }
 }
```
由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，……当i=n-1时，执行了1次。
所以总的执行次数为： n(n + 1)/2 = n^2/2 + n/2
用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留n^2/2；第三条，去除这个项相乘的常数，也就是去除1/2，最终这段代码的时间复杂度为O(n^2)。

##### 最坏情况与平均情况

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
